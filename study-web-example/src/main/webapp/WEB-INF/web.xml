<?xml version="1.0" encoding="UTF-8"?>
<web-app>

<!--	<listener>-->
<!--		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>-->
<!--	</listener>-->

<!--	<context-param>-->
<!--		<param-name>contextConfigLocation</param-name>-->
<!--		<param-value>/WEB-INF/app-context.xml</param-value>-->
<!--	</context-param>-->

	<servlet>
		<servlet-name>app</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
<!--			配置指定的spring.xml-->
			<param-value>/WEB-INF/spring.xml</param-value>
<!--			不使用默认的XmlWebApplicationContext，而是用我们自己定义的context-->
<!--			<param-name>contextClass</param-name>-->
<!--			<param-value>com.xxx.xxxContext</param-value>-->
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
<!--	上面配置的DispatcherServlet的mapping	-->
		<servlet-name>app</servlet-name>
		<url-pattern>/app/*</url-pattern>
	</servlet-mapping>
<!--
web.xml此文件并不是由springmvc去使用的，而是由tomcat读取并使用，而tomcat规定此文件只能在webapp/WEB-INF目录下
tomcat启动时将会读取此文件中的<servlet>标签，并根据<load-on-startup>标签来决定什么时候初始化DispatcherServlet，如果为1，则tomcat启动时即会初始化DispatcherServlet，如果为0则等到用户访问<servlet-mapping>中的url时才会初始化DispatcherServlet。
访问web应用时，需要加上idea tomcat中配置的Application Context的路径，因为tomcat中可以部署很多应用，所以必须要指定此应用的context。之后，我们还需要指定此DispatcherServlet的mapping，即我们上面<servlet-mapping>标签中定义的url，即'/app/*'，这样，tomcat才会把请求交给此DispatcherServlet来处理。之后DispatcherServlet才会处理我们定义的Controller中的mapping，并返回相应的结果。

初始化DispatcherServlet时，将会调用此类的init()，即HttpServletBean.init()，此初始化方法初始化了WebApplicationContext容器（默认为XmlWebApplicationContext实现类），即我们初始化的DispatcherServlet内部含有一个WebApplicationContext容器，此容器中包含了我们定义的Controller等等一些bean。HttpServletBean此类属于springmvc，而此类的父类HttpServlet及以上，则属于javax，即tomcat。
WebApplicationContext初始化调用链：HttpServletBean.init()->FrameworkServlet.initServletBean()->FrameworkServlet.createWebApplicationContext(parent)

 -->

</web-app>
